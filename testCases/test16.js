/* eslint no-undef: off, camelcase: off */

horstmann_codecheck.setup.push({
  sections: [
    {
      type: 'run',
      runs: [
        {
          mainclass: 'boxed.py',
          images: [
            {
              data: 'iVBORw0KGgoAAAANSUhEUgAAANwAAADcAgMAAABmNCcSAAAADFBMVEUA/wD/AAAAAAAAAABmnah3AAAAgElEQVR4Xu3asQnDQBAAwX/hyP0X4FiR+nPixNEzBvOZYCe8Y7kGbp5jy7EO/lRnd+keY7yvdfj1c/F8bd+rszqrszqrszqrszqrszqrszqrszqrszqrszqrszqrszqrszqrszqrszqrszqrszqrszqrszqrszqrs7t0s39vqrMPw1MHDeuAvqMAAAAASUVORK5CYII='
            }
          ]
        }
      ]
    }
  ],
  requiredFiles: {
    'boxed.py': {
      editors: [`
##SOLUTION
##OUT boxed.gif

from ezgraphics import GraphicsImage
      
##EDIT image = GraphicsImage(. . .)
##HIDE
image = GraphicsImage(220, 220)
for row in range(10) :
   for col in range(220) :
      image.setPixel(row, col, 0, 0, 0)
      image.setPixel(row + 210, col, 0, 0, 0)
for row in range(200) :
   for col in range(0, 10) :
      image.setPixel(row + 10, col, 0, 0, 0)
      image.setPixel(row + 10, col + 210, 0, 0, 0)
   for col in range(10, 110) :
      image.setPixel(row + 10, col, 255, 0, 0)
      image.setPixel(row + 10, col + 100, 0, 255, 0)
##EDIT . . .      
image.save("boxed.gif")     `]
    }
  },
  description: '\u003Cdiv\u003E\u003Cp\u003EComplete the following program that creates and saves a 200 x 200 pixel image \ncontaining two vertical stripes enclosed within a 10 pixel wide black border.\u003C/p\u003E\n\u003Cp\u003E\u003Cimg src="data:image/png;base64,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"/\u003E\u003C/p\u003E\n\u003C/div\u003E\n',
  hiddenFiles: {
    'boxed-img.gif': {
      data: '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'
    },
    'ezgraphics.py': "##HIDE\n##OUT boxed.gif\n## \n#\n# This module is a simplified version of the ezgraphics module (v2.1) \n# for use with CodeCheck. Instead of using Tk to display graphics and\n# images in a GUI window, it builds and saves the result in a PNG image.\n# \n# Version: 2.1.2\n#\n# Changes since version 2.1\n# Fixed the setFill, setColor, and setOutline canvas methods to work with\n# color names that contain blank spaces. tkinter allows blank spaces in \n# the names, but PIL does not.\n#\n# Changes since version 2.1.1\n# Fixed the setPixel method to work with floating-point RGB values. If a\n# floating point number given, it is truncated to an integer. tkinter\n# correctly handles floating-point values, but PIL does not.\n#\nfrom PIL import Image, ImageDraw, ImageColor, ImageFont\n\nOUTPUT_FILENAME = \"out.png\"\n\nclass GraphicsWindow :\n  def __init__(self, width = 400, height = 400) :\n    if width is None and height is None :\n      width = 400\n      height = 400\n\n    self._canvas = GraphicsCanvas(self, width, height) \n    \n  def canvas(self) :\n    return self._canvas\n    \n  def wait(self) :\n    img = self._canvas._pilImage\n    img.save(OUTPUT_FILENAME)\n  \n  def setTitle(self, title) :\n    pass\n  \n  def isValid(self) :\n    return True\n    \n  def hide(self) :\n    pass\n  \n  def show(self) :\n    pass\n  \n  def close(self) :\n    pass\n  \n  def quit(self) :\n    pass\n  \n  def getMouse(self) :\n    return (0, 0)\n    \n  def getKey(self) :\n    return \"\"\n    \n  def sleep(self, msTime) :\n    pass\n  \n  def menu(self) :\n    return None\n    \n  def showMenu(self) :\n    pass\n  \n  def hideMenu(self) :\n    pass\n  \n  def showStatus(self) :\n    pass\n  \n  def hideStatus(self) :\n    pass\n  \n  def setStatus(self, text=\"\") :\n    pass\n  \n  def configStatus(self, **options) :\n    pass\n  \n  def enableEvents(self, *events) :\n    pass\n  \n  def clearEvents(self, *events) :\n    pass\n  \n  def setEventHandler(self, handler) :\n    pass\n  \n  def setTimer(self, msTime) :\n    pass\n  \n  def clearTimer(self) :\n    pass    \n  \n  def onMenuSelect(self, event) :\n    pass\n    \n  def onMouseMove(self, event) :\n    pass\n    \n  def onMouseDrag(self, event) :\n    pass\n  \n  def onMouseDown(self, event):\n    pass\n \n  def onMouseUp(self, event):\n    pass\n  \n  def onKeyPress(self, event) :\n    pass\n  \n  def onAlarm(self, event) :\n    pass\n  \n  \nclass GraphicsCanvas :\n  def __init__(self, win, width, height) :\n   \n     # The win argument is ignored in the codecheck version.\n    self._win = win\n   \n     # Maintain the options used for drawing objects and text.\n    self._polyOpts = {\"outline\" : (0, 0, 0), \"width\" : 1, \"dash\" : None, \"fill\" : None}\n    self._arcStyle = \"pieslice\"\n    self._textOpts = {\"justify\" : \"left\", \"anchor\" : \"nw\",\n                      \"fill\" : \"black\",\n                      \"font\" : (\"helvetica\", 10, \"normal\")}\n    self._font = None\n    self._bgColor = (255, 255, 255)    \n                      \n     # Create the PIL image.\n    self._pilImage = Image.new(\"RGB\", (width, height), (255, 255,255))\n    self._pilDraw = ImageDraw.Draw(self._pilImage)\n    \n  ## Changes the height of the canvas.\n  #\n  def setHeight(self, size):\n    if type(size) != int or size \u003C= 0 :\n      raise GraphicsParamError( \"The window height must be \u003E= 1.\" )\n    if size \u003C self.height() :\n      self._shrinkImage(self.width(), size)\n    else :\n      self._enlargeImage(self.width(), size)\n\n  ## Changes the width of the canvas.\n  #\n  def setWidth(self, size):    \n    if type(size) != int or size \u003C= 0 :\n      raise GraphicsParamError(\"The window width must be \u003E= 1.\")\n    if size \u003C self.width() :\n      self._shrinkImage(size, self.height())\n    else :\n      self._enlargeImage(size, self.height())\n\n  def _shrinkImage(self, width, height) :\n    self._pilImage = self._pilImage.crop((0, 0, width, height))\n    self._pilDraw = ImageDraw.Draw(self._pilImage)\n    \n  def _enlargeImage(self, width, height) :\n    oldImage = self._pilImage\n    self._pilImage = Image.new(\"RGB\", (width, height), (255, 255,255))\n    self._pilImage.paste(oldImage, (0, 0))         \n    self._pilDraw = ImageDraw.Draw(self._pilImage)\n    \n  ## Returns the height of the canvas.\n  #\n  def height(self):\n    return self._pilImage.size[1]\n  \n  ## Returns the width of the canvas.\n  #\n  def width(self):\n    return self._pilImage.size[0]\n     \n  ## Clears the canvas by removing all items previously drawn on it. \n  #\n  def clear(self):\n    width = self.width()\n    height = self.height()\n    self._pilImage = Image.new(\"RGB\", (width, height), (255, 255,255))\n    self._pilDraw = ImageDraw.Draw(self._pilImage)\n   \n  ## Sets the current background color of the canvas. (not used)\n  #   \n  def setBackground(self, red, green = None, blue = None) :\n    if type(red) == int :\n      color = \"#%02X%02X%02X\" % (red, green, blue) \n    elif type(red) != str :\n      raise GraphicsParamError(\"Invalid color.\")\n    else :\n      color = red\n\n  ## Sets the fill color used when drawing new polygon shapes. \n  #    \n  def setFill(self, red = None, green = None, blue = None) :\n    if red is None :\n      color = None\n    elif type(red) == int :\n      color = (red, green, blue)       \n    elif type(red) != str :\n      raise GraphicsParamError(\"Invalid color.\")\n    else :\n      string = red.replace(\" \", \"\")\n      color = ImageColor.getrgb(string)\n    self._polyOpts[\"fill\"] = color\n        \n  ## Sets the outline color used when drawing new polygon shapes and the\n  #\n  def setOutline(self, red = None, green = None, blue = None) :\n    if red is None :\n      color = None\n    elif type(red) == int :\n      color = (red, green, blue)  \n    elif type(red) != str :\n      raise GraphicsParamError(\"Invalid color.\")\n    else :\n      string = red.replace(\" \", \"\")\n      color = ImageColor.getrgb(string)\n    self._polyOpts[\"outline\"] = color\n    self._textOpts[\"fill\"] = color\n     \n  ## Sets both the fill and outline colors used when drawing shapes and text\n  #  on the canvas. \n  #\n  def setColor(self, red, green = None, blue = None) :\n    if type(red) == int :\n       color = (red, green, blue)\n    elif type(red) != str :\n       raise GraphicsParamError(\"Invalid color.\")\n    else :\n       string = red.replace(\" \", \"\")\n       color = ImageColor.getrgb(string)\n    self._polyOpts[\"outline\"] = color\n    self._polyOpts[\"fill\"] = color\n    self._textOpts[\"fill\"] = color     \n    \n  ## Sets the width of lines drawn on the canvas. \n  #\n  def setLineWidth(self, size):\n    if type(size) != int or size \u003C= 0 :\n      raise GraphicsParamError(\"Invalid line width.\")\n    self._polyOpts[\"width\"] = size\n    if self._polyOpts[\"dash\"] :\n      self._polyOpts[\"dash\"] = (4 * size, 4 * size)\n\n  ## Sets the style used to drawn lines on the canvas. (not used) \n  #\n  def setLineStyle(self, style):\n    if style == \"dashed\" :\n      width = self._polyOpts[\"width\"]\n      self._polyOpts[\"dash\"] = (4 * width, 4 * width)\n    else :\n      self._polyOpts[\"dash\"] = None\n\n\n  ## Sets the style used when drawing an arc on the canvas. \n  #\n  def setArcStyle(self, style) :\n    if style not in (\"pieslice\", \"chord\", \"arc\") :\n      raise GraphicsParamError(\"Invalid arc style.\")\n    self._arcStyle = \"pieslice\"\n  \n  ## Sets the font used to draw text on the canvas. \n  #  \n  def setTextFont(self, family = None, style = None, size = None ):\n    origFamily, origSize, origStyle = self._textOpts[\"font\"]\n    if family is None :\n      family = origFamily    \n    elif (family is not None and \n       family not in ('helvetica', 'arial', 'courier', 'times', 'times roman')) :\n      raise GraphicsParamError(\"Invalid font family.\")\n      \n    if style is None :\n      style = origStyle    \n    elif (style is not None and \n       style not in ('bold', 'normal', 'italic', 'bold italic')) :\n      raise GraphicsParamError( \"Invalid font style.\" )\n\n    if size is None :\n       size = origSize    \n    elif size is not None and (type(size) != int or size \u003C= 0) :\n      raise GraphicsParamError( \"Invalid font size.\" )\n       \n    self._textOpts[\"font\"] = (family, size, style)     \n\n  ## Sets the position that text is drawn in relation to a bounding box. \n  #\n  def setTextAnchor(self, position):\n    if position not in ('n', 's', 'e', 'w', 'nw', 'ne', 'sw', 'se', 'center') :\n      raise GraphicsParamError( \"Invalid anchor position.\" )       \n    self._textOpts[\"anchor\"] = position\n          \n  ## Sets the justification used to draw new multiline text on the canvas.\n  #\n  def setTextJustify(self, style):\n    if style in (\"left\", \"center\", \"right\") :\n      self._textOpts[\"justify\"] = style\n    else :\n      raise GraphicsParamError(\"Invalid justification value.\")\n    \n  ## Draws or plots a single point (pixel) on the canvas.\n  #\n  def drawPoint(self, x, y) :\n    self._pilDraw.point((round(x), round(y), round(x+1), round(y)), \n                        fill=self._polyOpts[\"outline\"])\n    return 0    \n\n  ## Draws a line segment on the canvas. \n  #\n  def drawLine(self, x1, y1, x2, y2):\n    self._pilDraw.line((round(x1), round(y1), round(x2), round(y2)), \n      fill=self._polyOpts[\"outline\"],\n      width=self._polyOpts[\"width\"])\n    return 0\n  \n  ## Draws an arrow or vector on the canvas. (Draws a line) \n  #\n  def drawArrow(self, x1, y1, x2, y2) :\n    return self.drawLine(x1, y1, x2, y2)\n    \n  ## Draws a rectangle on the canvas. \n  #\n  def drawRect(self, x, y, width, height) :\n    self._pilDraw.rectangle((round(x), round(y), \n                             round(x + width), round(y + height)), \n              outline=self._polyOpts[\"outline\"], fill=self._polyOpts[\"fill\"])\n    return 0\n  \n  def drawRectangle(self, x, y, width, height) :\n    return self.drawRect(x, y, width, height)\n                       \n  ## Draws a polygon on the canvas. \n  #\n  def drawPoly(self, *coords):\n    minCoords = 6\n    \n     # Unwrap the cooridinates which allows the method to accept individual \n     # vertices or a list of vertices.\n    if len(coords) == 1 and (type(coords[0]) == list or type(coords[0]) == tuple) :\n       expCoords = tuple(*coords)\n    else :\n       expCoords = coords\n       \n    if type(expCoords[0]) == list or type(expCoords[0]) == tuple :\n      minCoords = 3\n       \n    if len(expCoords) \u003C minCoords :\n      raise GraphicsParamError(\"At least 3 vertices must be provided.\")\n      \n    self._pilDraw.polygon(expCoords, \n              outline=self._polyOpts[\"outline\"], fill=self._polyOpts[\"fill\"])\n    return 0\n  \n  ## The same as drawPoly().\n  #\n  def drawPolygon(self, *coords) :\n    return self.drawPoly(*coords)\n      \n  ## Draws an oval on the canvas. \n  #\n  def drawOval(self, x, y, width, height):\n    self._pilDraw.ellipse((round(x), round(y), \n                           round(x + width), round(y + height)),\n              outline=self._polyOpts[\"outline\"], fill=self._polyOpts[\"fill\"])\n    return 0    \n            \n  ## Draws an arc or part of a circle on the canvas.\n  #\n  def drawArc(self, x, y, diameter, startAngle, extent) :\n    x = round(x)\n    y = round(y)\n    diameter = round(diameter)\n    startAngle = round(startAngle)\n    extent = round(extent)\n\n     # Tk draws arcs counter-clockwise, but PIL draws them clockwise.\n    temp = startAngle\n    endAngle = 360 - temp\n    startAngle = 360 - temp - extent\n    if self._arcStyle == \"pieslice\" :\n      self._pilDraw.pieslice((x, y, x + diameter, y + diameter), \n                          startAngle, endAngle,\n                          outline=self._polyOpts[\"outline\"],\n                          fill=self._polyOpts[\"fill\"])\n      \n    elif self._arcStyle == \"chord\" :\n      self._pilDraw.chord((x, y, x + diameter, y + diameter), \n                          startAngle, endAngle,\n                          outline=self._polyOpts[\"outline\"],\n                          fill=self._polyOpts[\"fill\"])\n      \n    elif self._arcStyle == \"arc\" :\n      self._pilDraw.arc((x, y, x + diameter, y + diameter), \n                          startAngle, endAngle,        \n                          fill=self._polyOpts[\"outline\"])\n    \n    return 0\n  \n  ## Draws text on the canvas. \n  #  \n  def drawText(self, x, y, text):\n    self._pilDraw.text((round(x), round(y)), text,\n                fill=self._textOpts[\"fill\"],\n                anchor=self._textOpts[\"anchor\"],\n                font=self._font)\n    return 0\n         \n  ## Draws an image onto the canvas.\n  #\n  def drawImage(self, x, y = None, image = None) :\n    if type(x) == GraphicsImage :\n      image = x\n      width = image.width()\n      height = image.height()\n      x = 0\n      y = 0\n      self._pilImage = Image.new(\"RGB\", (width, height), (255, 255,255))\n      self._pilDraw = ImageDraw.Draw(self._pilImage)\n      \n    self._pilImage.paste(image._pilImage, (round(x), round(y)))\n    return 0\n  \n  def shiftItem(self, itemId, dx, dy) :\n    pass\n  \n  def scaleItem(self, itemId, xScale, yScale, xOffset = None, yOffset = None) :\n    pass\n  \n  def removeItem(self, itemId) :\n    pass\n  \n  def showItem(self, itemId) :\n    pass\n  \n  def hideItem(self, itemId) :\n    pass\n  \n  def raiseItem(self, itemId, aboveId = None) :    \n    pass\n\n  def lowerItem(self, itemId, belowId = None) :\n    pass\n  \n  def __contains__(self, itemId):\n    return True\n  \n  def itemType(self, itemId) :\n    return \"\"\n    \n  def items(self) :\n    return []    \n    \n  def itemAbove(self, itemId) :\n    return 0\n\n  def itemBelow(self, itemId) :\n    return 0\n    \n    \n## This class defines a basic top level window that can display a\n#  digital GraphicsImage.\n#\nclass ImageWindow(GraphicsWindow) :\n  \n  ## Creates a new window for displaying images. This provides a quick\n  #  way to display images without having to access and draw on the \n  #  canvas of a graphics window.\n  #         \n  def __init__(self) :\n    super().__init__(None, None)\n    self._imgId = None\n    \n  ## Displays an image in the window. The window is resized to fit tightly\n  #  around the image.\n  #  @param image  The GraphicsImage object containing the image to \n  #                be displayed.\n  #\n  def display(self, image = None) :\n    if image is None : return\n    canvas = self._canvas\n    width = image.width()\n    height = image.height()\n    canvas._pilImage = Image.new(\"RGB\", (width, height), (255, 255, 255)) \n    canvas._pilImage.paste(image, (0, 0))\n    \n## This class defines an RGB digital image that is contained within an\n#  ImageWindow.\n#\nclass GraphicsImage :\n  \n  ## Creates a new graphics image. \n  #\n  def __init__(self, width = None, height = None) :\n     # Create the photo image.\n    if height is None and type(width) == str :\n      filename = width\n      self._pilImage = Image.open(filename)\n      if self._pilImage.mode != \"RGB\" :\n        self._pilImage = self._pilImage.convert(\"RGB\")\n    else :\n      self._pilImage = Image.new(\"RGB\", (width, height), (255, 255,255))\n  \n  ## Gets the width of the image in pixels.\n  #  @return The width of the image.\n  #\n  def width(self) :\n    return self._pilImage.size[0]\n\n  ## Gets the height of the image in pixels.\n  #  @return The width of the image.\n  #\n  def height(self) :\n    return self._pilImage.size[1]\n\n  ## Sets a pixel to a given RGB color.\n  #\n  def setPixel(self, row, col, *rgbColor) :\n    if (row \u003C 0 or row \u003E= self.height() or\n        col \u003C 0 or col \u003E= self.width()) : \n      return\n    if len(rgbColor) == 1 :\n      if type(rgbColor[0]) == str :\n        if rgbColor[0][0] == \"#\" :\n          color = ImageColor.getrgb(rgbColor)\n        else :\n          color = (0, 0, 0)\n      else :\n        color = tuple(*rgbColor)\n    elif len(rgbColor) == 3 :\n      color = rgbColor      \n    col = round(col)\n    row = round(row)\n    color = (int(color[0]), int(color[1]), int(color[2]))    \n    self._pilImage.putpixel((col, row), color)\n  \n  ## Returns a 3-tuple containing the RGB color of a given pixel.\n  #\n  def getPixel(self, row, col) :\n    row = round(row)\n    col = round(col)\n    result = self._pilImage.getpixel((col, row))\n    if type(result) == int :\n      return (result, result, result)\n    else :\n      return result\n\n  ## Returns the red component of the RGB color of a given pixel.\n  #\n  def getRed(self, row, col) :\n    pixel = self.getPixel(row, col)\n    return pixel[0]\n    \n  ## Returns the green component of the RGB color of a given pixel.\n  #\n  def getGreen(self, row, col) :\n    pixel = self.getPixel(row, col)\n    return pixel[1]\n    \n  ## Returns the blue component of the RGB color of a given pixel.\n  #\n  def getBlue(self, row, col) :\n    pixel = self.getPixel(row, col)\n    return pixel[2]\n    \n  ## Clears the image and removes all of the pixels but the size of the \n  #  image remains the same.\n  #\n  def clear(self) :\n    width = self.width()\n    height = self.height()    \n    self._pilImage = Image.new(\"RGB\", (width, height), (255, 255,255))\n    \n  ## Creates a duplicate copy of the image.\n  #\n  def copy(self) :\n    image = GraphicsImage(10, 10)\n    image._pilImage = self._pilImage.copy()\n    return image\n  \n  ## Saves the digital image to a file in either the gif or ppm format.\n  #\n  def save(self, filename, format=\"gif\") :\n    if format not in (\"gif\", \"ppm\") :\n      raise GraphicsParamError( \"Invalid image format.\")\n    self._pilImage.save(filename, format=format)\n\n\n# --- Defines special graphics exceptions that are raised when an error\n# --- occurs in a GraphicsWindow method.\n\nclass GraphicsError(Exception) :\n  def __init__( self, message ):\n    super(GraphicsError, self).__init__( message )\n\nclass GraphicsObjError(GraphicsError) :\n  def __init__( self ):\n    super(GraphicsError, self).__init__( \"Invalid object id.\" )\n\nclass GraphicsWinError(GraphicsError) :\n  def __init__( self ):\n    super(GraphicsWinError, self).__init__(\n              \"Operation can not be performed on a closed window.\" )\n\nclass GraphicsParamError(GraphicsError) :\n  def __init__( self, message ):\n    super(GraphicsParamError, self).__init__( message )\n    \n"
  }
})
