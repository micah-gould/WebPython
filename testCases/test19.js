/* eslint no-undef: off, camelcase: off */

horstmann_codecheck.setup.push({
  sections: [
    {
      type: 'run',
      runs: [
        {
          mainclass: 'triangles.py',
          images: [
            {
              data: 'iVBORw0KGgoAAAANSUhEUgAAAMgAAADIAgMAAADQNkYNAAAADFBMVEX///8A/wD/AAAAAAA6A69nAAACkElEQVR4XpXPwXHEMAxDUUcXN+Eit4n0tSWkpFiyZUsUSQA4YuYd/rbJ+/n9sxdaOewDV3b7wJXytRda2T72QiubHFM2OaZsckzZ5JiTqDEnUWNOosacRI2pRIypRIypRIypRIxpRItpRItpRItpRIu5iBRzESnmIlLMRaSYmygxN1FibqLE3ESJ6USI6USI6USI6USIeQgf8xA+5iF8zEP4mJfQMS+hY15Cx7yEjhkIGzMQNmYgbMxA2JiRkDEjIWNGQsaMhIyZCBczES5mIlzMRLiYmVAxM6FiZkLFzISKMYSJMYSJMYSJMYSJsYSIsYSIsYSIsYSIWQiOWQiOWQiOWQiOWQmMWQmMWQmMWQmMcQiKcQiKcQiKcQiK8QiI8QiI8QiI8QiIcUke45I8xiV5jEvyGJ+kMT5JY3ySxvgkjQlIFhOQLCYgWUxAspiIJDERSWIiksREJIkJSRwTkjgmJHFMSOKYmIQxMQljYhLGxCSMSUgUk5AoJiFRTEKimIwEMRkJYjISxGQkiEmJH5MSPyYlfkxK/JicuDE5cWNy4sbkxI0BxIsBxIsBxIsBxItBxIlBxIlBxIlBxImBZI2BZI2BZI2BZI3BZInBZInBZInBZIkhiI0hiI0hiI0hiI1hiIlhiIlhiIlhiImhyBxDkTmGInMMReYYjkwxHJliODLFcGSKIckYQ5IxhiRjDEnGGJYMMSwZYlgyxLBkiKHJG0OTN4YmbwxN3hiePDE8eWJ48sTw5IkRSI8RSI8RSI8RSI9RyB2jkDtGIXeMQu4YiVwxErliJHLFSOSK0UiL0UiL0UiL0UiLEUmNEUmNEUmNEUmNUcmhk10nZ4xKzhiZHDrZdVK+Mtk+Ojl0sv8D7mNES/JNO+IAAAAASUVORK5CYII='
            }
          ]
        }
      ]
    }
  ],
  requiredFiles: {
    'triangles.py': {
      editors: [`
##SOLUTION
##OUT triangles.gif
from ezgraphics import GraphicsImage
   
image = GraphicsImage(200, 200)
##HIDE
for row in range(200) :
   for col in range(0, row) :
      image.setPixel(row, col, 255, 0, 0)
      image.setPixel(200 - row, 200 - col, 0, 255, 0)
##EDIT . . .      
image.save("triangles.gif")`]
    }
  },
  description: '\u003Cdiv\u003E\u003Cp\u003EComplete the following program that creates and saves a 200 x 200 pixel image \ncontaining two triangles.\u003C/p\u003E\n\u003Cp\u003E\u003Cimg src="data:image/png;base64,R0lGODdhyADIAIcAAP///wD/AP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAyADIAEAI/wABCBxIsKDBgwgTKlzIsKHDhxAjSpyoUIDFixYBBNjIsaPHjyBDihxJsqTJkyhTqlzJMoCAlzBjyhQAIIDNmzhz6tzJs6fPn0CDCh1KtKhRoAKSKl3KtKlSAAGiSp1KtarVq1izat3KtavXr2DDThVAtqzZs2jTmgUQoK3bt3Djyp1Lt67du3jz6t3LN6+Av4ADCx5MuHBgAAESK17MuLHjx5AjS55MubLly5gbC9jMubPnz6BDi+YMIIDp06hTq17NurXr17Bjy55Ne7aA27hz697Nu7fv3wIABBhOvLjx48iTK1/OvLnz59CjIxdAvbr169iza9/OfTuAAODDi/8fT768+fPo06tfz759ewHw48ufT7++/fv489MHEKC/f4ABBA4kWNDgQYQJFS5k2NDhwwACJE6kWNHiRYwZNW7kKBFAAJAhRY4kWdLkSZQpVa5kyVLAS5gxZc6kWdPmTZw5bwII0NPnT6BBhQ4lWtToUaRJgwpg2tTpU6hRpU6lWtXq1acAAmzl2tXrV7BhxY4lW9ZsWQFp1a5l29btW7hx5c6lSxdAALx59e7l29fvX8CBBQ/WK8DwYcSJFS9m3NjxY8iRJS8GEMDyZcyZNW/m3NnzZ9CdBYwmXdr0adSpVa9m3dr1a9gAAsymXdv2bdy5de/m3TuAAODBhQ8nXtz/+HHkyZUvZ97cOIAA0aVPp17d+nXs2bVTF9Dd+3fw4cWPJ1/e/Hn06dWvBxDA/Xv48eXPp1/fPn0B+fXv59/fP0ABAgcSLGjwIMKEChcybOhwIYAAEidSrGjxIsaMGgVw7OjxI8iQIkeSLGnyJMqUKlUCCODyJcyYMmfSrOlSAM6cOnfy7OnzJ9CgQocSLWr0aE8AAZYyber0KdSoTAVQrWr1KtasWrdy7er1K9iwYseGBRDgLNq0ateyRSvgLdy4cufSrWv3Lt68evfy7ev3r1wAAQYTLmz48GABihczbuz4MeTIkidTrmz5MubMmisDCOD5M+jQAkaTLm36NOrU/6pXs27t+jXs2LJn0x4NIADu3AEE8BYAIADw4MKHEy9u/Djy5MqXM2/u/Dn06MMFUK9unTqAANq3c+/u/Tv48OLHky9v/jz69OrRC2jv/j18+AAC0K9v/z7+/Pr38+/vH2AAgQMJFjR4EGFChQsZNlQoAGJEiRMpVgQQAGNGjRs5dvT4EWRIkSNJljR5EqUAlStZtnT5EiaAADNp1rR5E2dOnTt59vT5E2hQoTsFFDV6FGlSpUuXAgjwFGpUqVOpVrV6FWtWrVu5dvX6VEBYsWPJljV7Fq1ZAAHYtnX7Fm5cuXPp1rV7F29evXUF9PX7F3BgwYMJFwYMIEBixYsZN/92/BhyZMmTKVe2fFmxAM2bOXf2/Bl0aNGjNQMIcBp1atWrWbd2/Rp2bNmzacMWcBt3bt27eff2/Rv4bwABiBc3fhx5cuXLmTd3/hx69OICqFe3fh17du3buXf3jh1AAPHjyZc3fx59evXr2bd3r15AfPnz6de3fx9/fv37+QsAADCAwIEECxo8iDChwoUMGzoUKCCixIkUK1q8iDGjxo0cMQIIADKkyJEkS5o8iTKlypUmBbh8CTOmzJk0a9q8iTOnzpcAAvj8CTSo0KFEixo9ijSpgKVMmzp9CjWq1KlUq1q9ShVAgK1cu3r9Cjas2LFky3oVgDat2rVs27p9Czf/rty5dOuqBRAgr969fPv6/Qs4sGDAAgobPow4seLFjBs7fgw5suTHAAJYvow5s+bNnDt7/hxAgOjRpEubPo06terVrFu7fg2bNIAAtGvbvo07t+7dvG0L+A08uPDhxIsbP448ufLlzJsnBxAguvTp1Ktbv469uoDt3Lt7/w4+vPjx5MubP48+vXruAAK4fw8/vvz59OcLuI8/v/79/Pv7ByhA4ECCBQ0eRJhQ4UKGDR06BBBA4kSKFS1evChA40aOHT1+BBlS5EiSJU2eRJlSpQAAAVy+hBlTpkwBNW3exJlT506ePX3+BBpU6FCiRXkCCJBU6VKmSwU8hRpV6lSq/1WtXsWaVetWrl29fvUKIMBYsmUDCECbVu1atm3dvoUbV+5cunXt3sWbly2AAH0FCAAQQPBgwoUNH0acWPFixo0dP4YcWfLkwwIsXwYQQPNmzp09fwYdWvRo0qVNn0adWvXqzQJcv4YNIMBs2rVt38adW/du3r19/wYeXPjw4QKMH0eOHEAA5s2dP4ceXfp06tWtX8eeXft27tgFfAcfXjx4AAHMn0efXv169u3dv4cfX/58+vXtuxeQX/9+/v0FAAQQYCDBggYPIkyocCHDhg4fQowoceJBARYvYsyoMSOAAB4/ggwpciTJkiZPokypciXLli49CogpcybNmjZjAv8IoHMnz54+fwINKnQo0aJGjyJNilQA06ZOn0KNChVAgKpWr2LNqnUr165ev4INK3Ys2a8CzqJNq3Yt27ZnAQSIK3cu3bp27+LNq3cv375+/wK+K2Aw4cKGDyNOfBhAgMaOH0OOLHky5cqWL2POrHkz58cCPoMOLXo06dKmBQAIoHo169auX8OOLXs27dq2b+POLWA3796+fwMPLtw3gADGjyNPrnw58+bOn0OPLn069egCrmPPrn079+7evQMIIH48+fLmz6NPr349+/bu38NPL2A+/fr27+PPr38/fQABAAYQOJBgQYMHESZUuJBhQ4cPIRIUMJFiRYsXMWbUuBH/I4AAH0GGFDmSZEmTJ1GmVLmSZcsAAmDGlDmTZk2bN3HmBBCAZ0+fP4EGFTqUaFGjR5EmPSqAaVOnT6FGlTqValWnAAJk1bqVa1evX8GGFTuWbFmzYAWkVbuWbVu3b+HGlfsWQAC7d/Hm1buXb1+/fwEHFjw4rwDDhxEnVryYcWPHjyEDCDCZcmXLlzFn1ryZc2fPn0EHEDCadGnTp1GnVr2adevSAALElj2bdm3bt3Hn1r2bd+/dAoAHFz6ceHHjx5EnV24cQADnz6FHlz6denXr17Fn105dQHfv38GHFz+efHnz588DCLCefXv37+HHlz+ffn3799sL0L+ff3///wAFCBxIsKDBgwgTKlx4EECAhxAjSpxIsaLFixgzatwooKPHjyBDihxJsqTJkyhFAgjAsqXLlzBjypxJs6bNmzQF6NzJs6fPn0CDCh1KtOhQAAGSKl3KtKnTp1CjSp1KtamAq1izat3KtavXr2DDih0rAECAs2jTql3Ltq3bt3Djyj0roK7du3jz6t3Lt6/fv4AD4wUQoLDhw4gTK17MuLHjx44FSJ5MubLly5gza97MubPnzAACiB5NurTp06hTq17N+rSA17Bjy55Nu7bt27hz696tG0CA38CDCx9OvLjx48iTAxfAvLnz59CjS59Ovbr169izMwcQoLv37+DDi/8fT768efMC0qtfz769+/fw48ufT7++/fYAAujfz7+/f4ABBA4kWNDgQYQJDwpg2NDhQ4gRJU6kWNHiRYwZKQII0NHjR5AhRY4kWdKkRwEpVa5k2dLlS5gxZc6kWdNmTQABdO7k2dPnT6BBhQoVUNToUaRJlS5l2tTpU6hRpU4tCiDAVaxZtW7l2tXr160CxI4lW9bsWbRp1a5l29btW7hmAQSgW9fuXbx59e7lS1fAX8CBBQ8mXNjwYcSJFS9m3PgwgACRJU+mXNnyZcyXBWzm3NnzZ9ChRY8mXdr0adSpTwMI0Nr1a9ixZc+m/VrAbdy5de/m3dv3b+DBhQ8nXtz/uAAAAZQvZ97c+XPo0QVMp17d+nXs2bVv597d+3fw4cVbBxDA/Hn06dWvZ59ewHv48eXPp1/f/n38+fXv59/fP0ABAgcOBBDgIMKEChcybBhAAMSIEidSrGjxIsaMGjdy7Ojx40YAAUaSLGnyJEqTAlaybOnyJcyYMmfSrGnzJs6cOnUCCODzJ9CgQocGEGD0KNKkSpcyber0KdSoUqdSrWr1KIAAWrdy7eqVq4CwYseSLWv2LNq0ateybev2Ldy4ZgEEqGv3Lt68Avby7ev3L+DAggcTLmz4MOLEihcTBhDgMeTIkh8LqGz5MubMmjdz7uz5M+jQokeTLi0aQIDU/6pXqxbg+jXs2LJn065t+zbu3Lp38+7t+zeAAMKHDxdg/Djy5MqXM2/u/Dn06NKnU69u/TpyAAG2bxfg/Tv48OLHky9v/jz69OrXs2/v/j15AAEEAAhg/z7+/Pr38+/vH2AAgQMJFjR4EGFChQsZNnT4EOJBARMBBLB4EWNGjRs5dvT4EWRIkSNJljR5UqMAlSoBBHD5EmZMmTNp1rR5E2dOnTt59vT5E6YAoUMFAAhwFGlSpUuZNnX6FGpUqVOpVrV6FetRAVu5cgUQAGxYsWPJljV7Fm1atWvZtnX7Fm5cAXPp1hUAIEBevXv59vX7F3BgwYMJFzZ8GHFixAIYN/923BhAAMmTKVe2fBlzZs2bOXf2/Bl0aNGfBZQ2fRo1gACrWbd2/Rp2bNmzade2fRt3bt27bQvw/Rt4cN8AAhQ3fhx5cuXLmTd3/hx6dOnTqVd3LgB7du3btQMI8B18ePHjyZc3fx59evXr2bd3/968APnz6de3DyBAfv37+ff3DzCAwIEECxo8iDChwoUMGzp8CNGhgIkUK1q8OBFAgI0cO3r8CDKkyJEkS5o8iTKlypUeBbh8CTOmTJgAAti8iTOnzp08e/r8CTSo0KFEixq9KSCp0qVMmzYFECCq1KlUq1q9ijWr1q1cu3r9CjZsAAFky5o9izatAAAB2rp9Czf/rty5dOvavYs3r969fPkK+As4sODBhAEDCIA4seLFjBs7fgw5suTJlCtbvlxZgObNnDt7/twZQIDRpEubPo06terVrFu7fg07tmzXAmrbvo07t27dAAL4/g08uPDhxIsbP448ufLlzJsfFwA9uvTp1KtbFwAggPbt3Lt7/w4+vPjx5MubP48+fXgB7Nu7fw8/vvz2AALYv48/v/79/Pv7BxhA4ECCBQ0eRJhQ4UKGDR0KgBhR4kSKFS1OBBBA40aOHT1+BBlS5EiSJU2eRJmyowCWLV2+hBlTZkwAAWzexJlT506ePX3+BBpU6FCiRW8KQJpU6VKmTZ0+BRBA6lSq/1WtXsWaVetWrl29fgUbNoAAsmXNnkWbVu1asgACvIUbV+5cunXt3sWbV+9evn37CgAcWPBgwoUNHxYMIMBixo0dP4YcWfJkypUtX8ac+bIAzp09fwYdWvRo0AACnEadWvVq1q1dv4YdW/Zs2rVjC8CdW/du3r19//YNIMBw4sWNH0eeXPly5s2dP4cefbkA6tWtX8eeXft27gACfAcfXvx48uXNn0efXv169u3LC4AfX/58+vXt38cPH0AA/v39AwwgcCDBggYPIkyocCHDhg4fMhQgcSLFihYvYsyokSKAAB4/ggwpciTJkiZPokypciVLkAJewowpcybNmjZvzv8EEGAnz54+fwINKnQo0aJGjyJNulMA06ZOn0KNKnUqVakAAmDNqnUr165ev4INK3Ys2bJmBaBNq3Yt27Zu38KFCyAA3bp27+LNq3cv375+/wIODFgA4cKGDyNOrHgx48YCAASILHky5cqWL2POrHkz586eNwsILXo06dKmT6NOrVo0gACuX8OOLXs27dq2b+POrXu3bQG+fwMPLnw48eLGjwcHEGA58+bOn0OPLn069erWr2OPLmA79+7ev4MPL348efAAAqBPr349+/bu38OPL38+/frsBeDPr38///7+AQoQOJBgQYMHEQ4EEIBhQ4cPIUaUOJFiRYsXMWZ0KID/Y0ePH0GGFDmSZMmSAAKkVLmSZUuXL2HGlDmTZk2bKQXk1LmTZ0+fP4EGFTpUAIAAR5EmVbqUaVOnT6FGlTqVqgCrV7Fm1bqVa1evX8FeBRCAbFmzZ9GmVbuWbVu3b+G+FTCXbl27d/Hm1buXb1+7AAIEFjyYcGHDhxEnVryYcWPFAiBHljyZcmXLlzFn1lwZQADPn0GHFj2adGnTp1GnVl1aQGvXr2HHlj2bdm3bt2kDCLCbd2/fv4EHFz6ceHHjx4ELUL6ceXPnz6FHlz6d+nQAAbBn176de3fv38GHFz+e/HYB59GnV7+efXv37+HHlw8gQH379/Hn17+ff3///wADCBxIsKDBgwgNCljIsKHDhxAjSpxIsaLFhQACaNzIsaPHjyBDihxJsqTJAAJSqlzJsqXLlzBjypxJcyWAADhz6tzJs6fPn0CDCh06VIDRo0iTKl3KtKnTp1CjKgUQoKrVq1izat3KtavXr2C9ChhLtqzZs2jTql3Ltq3btAACyJ1Lt67du3jz6t3Lt29eAYADCx5MuLDhw4gTK16MGECAx5AjS55MubLly5gza6YsoLPnz6BDix5NurTp06hPAwjAurXr17Bjy55Nu7bt268F6N7Nu7fv38CDCx9OvLhxAAGSK1/OvLnz59CjS59OXbmA69iza9/Ovbv37+DDi/8ffx1AgPPo06tfz769+/fw48sPIKC+/fv48+vfz7+/f4ACBA4kWNDgQYQHAQRg2NDhQ4gRJU6kWNGiRQEZNW7k2NHjR5AhRY4kWbIjgAApVa5k2dLlS5gxZc6MKcDmTZw5de7k2dPnT6BBhfIEEMDoUaRJlS5l2tTpU6hMBUylWtXqVaxZtW7l2tXr160AAowlW9bsWbRp1a5l2/asALhx5c6lW9fuXbx59e7lqxdAAMCBBQ8mXNjwYcSJFQsW0NjxY8iRJU+mXNnyZcyZMwMI0NnzZ9ChRY8mXdr06c4CVK9m3dr1a9ixZc+mXdv2bQEAAuzm3dv3b+DBhQ8nXlz/wHHkyZUvZ97c+XPo0aVPp44cQADs2bVv597d+3fw4cELIF/e/Hn06dWvZ9/e/Xv48c8DCFDf/n38+fXv59/fP8AAAgcKFGDwIMKEChcybOjwIcSIEicuBBDgIsaMGjdy7OjxI8iNAkaSLGnyJMqUKleybOnyJUyVAALQrGnzJs6cOnfy7GlTANCgQocSLWr0KNKkSpcybZoUQICoUqdSrWr1KtasWqMK6Or1K9iwYseSLWv2LNq0atECCOD2Ldy4cufSrWv3roC8evfy7ev3L+DAggcTLmzYMIAAihczbuz4MeTIkiMLqGz5MubMmjdz7uz5M+jQokcLABDgNOrU/6pXs27t+jVrAbJn065t+zbu3Lp38+7t+zfw2QACEC9u/Djy5MqXMz8u4Dn06NKnU69u/Tr27Nq3c+8uHUCA8OLHky9v/jz69OIFsG/v/j38+PLn069v/z7+/PrjAwjgH2AAgQMJFjR4EGFChAIYNnT4EGJEiRMpVrR4EWNGjRMBBPD4EWRIkSNJliwpAGVKlStZtnT5EmZMmTNp1rQZE0AAnTt59vT5E2jQnwKIFjV6FGlSpUuZNnX6FGpUqU8BBLB6FWtWrVu5ds0qAGxYsWPJljV7Fm1atWvZtnXbFkAAuXPp1rV7F2/euQL49vX7F3BgwYMJFzZ8GHFixYsBBP9w/BhyZMmTKVcOIABzZs2bOXf2/Bl0aNGjSZc2fRozgACrWbd2/Rp27NgCaNe2fRt3bt27eff2/Rt4cOHDbQMIcBx5cuXLmTdfLgB6dOnTqVe3fh17du3buXf3/p06gADjyZc3fx59+vIC2Ld3/x5+fPnz6de3fx9/fv375QMIADCAwIEECxo8iDCAgIUMGzp8CDGixIkUK1q8iDGjxokAAnj8CDKkyJEkBZg8iTKlypUsW7p8CTOmzJk0a8IEECCnzp08e/rsKSCo0KFEixo9ijSp0qVMmzp9CrUpgABUq1q9ijWrVQFcu3r9Cjas2LFky5o9izat2rVqAQR4Czf/rty5dN8KuIs3r969fPv6/Qs4sODBhAsbPgwggOLFjBs7fiwgsuTJlCtbvow5s+bNnDt7/gw6dGQAAUqbPo06NWoBrFu7fg07tuzZtGvbvo07t+7dvF0DCAA8uPDhxIMLOI48ufLlzJs7fw49uvTp1Ktbv74cQIDt3Lt7/x5AgPjx5MubP48+vfr17Nu7fw8/vnz0AALYv48/f34B/Pv7ByhA4ECCBQ0eRJhQ4UKGDR0+hBhRIoAAFS1exGhRwEaOHT1+BBlS5EiSJU2eRJlS5cqSAAK8hBlTZgABNW3exJlT506ePX3+BBpU6FCiRYMCCJBU6dKlApw+hRpV6lSqs1WtXsWaVetWrl29cgUQQOxYsmIFnEWbVu1atm3dvoUbV+5cunXt3r0LIMBevn0F/AUcWPBgwoUNH0acWPFixo0dP4YsAEAAypUpC8CcWfNmzp09fwYdWvRo0qVNn0adOjOAAK1dC4AdW/Zs2rVt38adW/du3r19/wYefDaAAMUDCECeXPly5s2dP4ceXfp06tWtX8eevTmAAAEEfAcfXvx48uXNn0efXv169u3dv4dvHkBAADs="/\u003E\u003C/p\u003E \n\u003C/div\u003E\n',
  hiddenFiles: {
    'ezgraphics.py': "##HIDE\n## \n#\n# This module is a simplified version of the ezgraphics module (v2.1) \n# for use with CodeCheck. Instead of using Tk to display graphics and\n# images in a GUI window, it builds and saves the result in a PNG image.\n# \n# Version: 2.1.2\n#\n# Changes since version 2.1\n# Fixed the setFill, setColor, and setOutline canvas methods to work with\n# color names that contain blank spaces. tkinter allows blank spaces in \n# the names, but PIL does not.\n#\n# Changes since version 2.1.1\n# Fixed the setPixel method to work with floating-point RGB values. If a\n# floating point number given, it is truncated to an integer. tkinter\n# correctly handles floating-point values, but PIL does not.\n#\nfrom PIL import Image, ImageDraw, ImageColor, ImageFont\n\nOUTPUT_FILENAME = \"out.png\"\n\nclass GraphicsWindow :\n  def __init__(self, width = 400, height = 400) :\n    if width is None and height is None :\n      width = 400\n      height = 400\n\n    self._canvas = GraphicsCanvas(self, width, height) \n    \n  def canvas(self) :\n    return self._canvas\n    \n  def wait(self) :\n    img = self._canvas._pilImage\n    img.save(OUTPUT_FILENAME)\n  \n  def setTitle(self, title) :\n    pass\n  \n  def isValid(self) :\n    return True\n    \n  def hide(self) :\n    pass\n  \n  def show(self) :\n    pass\n  \n  def close(self) :\n    pass\n  \n  def quit(self) :\n    pass\n  \n  def getMouse(self) :\n    return (0, 0)\n    \n  def getKey(self) :\n    return \"\"\n    \n  def sleep(self, msTime) :\n    pass\n  \n  def menu(self) :\n    return None\n    \n  def showMenu(self) :\n    pass\n  \n  def hideMenu(self) :\n    pass\n  \n  def showStatus(self) :\n    pass\n  \n  def hideStatus(self) :\n    pass\n  \n  def setStatus(self, text=\"\") :\n    pass\n  \n  def configStatus(self, **options) :\n    pass\n  \n  def enableEvents(self, *events) :\n    pass\n  \n  def clearEvents(self, *events) :\n    pass\n  \n  def setEventHandler(self, handler) :\n    pass\n  \n  def setTimer(self, msTime) :\n    pass\n  \n  def clearTimer(self) :\n    pass    \n  \n  def onMenuSelect(self, event) :\n    pass\n    \n  def onMouseMove(self, event) :\n    pass\n    \n  def onMouseDrag(self, event) :\n    pass\n  \n  def onMouseDown(self, event):\n    pass\n \n  def onMouseUp(self, event):\n    pass\n  \n  def onKeyPress(self, event) :\n    pass\n  \n  def onAlarm(self, event) :\n    pass\n  \n  \nclass GraphicsCanvas :\n  def __init__(self, win, width, height) :\n   \n     # The win argument is ignored in the codecheck version.\n    self._win = win\n   \n     # Maintain the options used for drawing objects and text.\n    self._polyOpts = {\"outline\" : (0, 0, 0), \"width\" : 1, \"dash\" : None, \"fill\" : None}\n    self._arcStyle = \"pieslice\"\n    self._textOpts = {\"justify\" : \"left\", \"anchor\" : \"nw\",\n                      \"fill\" : \"black\",\n                      \"font\" : (\"helvetica\", 10, \"normal\")}\n    self._font = None\n    self._bgColor = (255, 255, 255)    \n                      \n     # Create the PIL image.\n    self._pilImage = Image.new(\"RGB\", (width, height), (255, 255,255))\n    self._pilDraw = ImageDraw.Draw(self._pilImage)\n    \n  ## Changes the height of the canvas.\n  #\n  def setHeight(self, size):\n    if type(size) != int or size \u003C= 0 :\n      raise GraphicsParamError( \"The window height must be \u003E= 1.\" )\n    if size \u003C self.height() :\n      self._shrinkImage(self.width(), size)\n    else :\n      self._enlargeImage(self.width(), size)\n\n  ## Changes the width of the canvas.\n  #\n  def setWidth(self, size):    \n    if type(size) != int or size \u003C= 0 :\n      raise GraphicsParamError(\"The window width must be \u003E= 1.\")\n    if size \u003C self.width() :\n      self._shrinkImage(size, self.height())\n    else :\n      self._enlargeImage(size, self.height())\n\n  def _shrinkImage(self, width, height) :\n    self._pilImage = self._pilImage.crop((0, 0, width, height))\n    self._pilDraw = ImageDraw.Draw(self._pilImage)\n    \n  def _enlargeImage(self, width, height) :\n    oldImage = self._pilImage\n    self._pilImage = Image.new(\"RGB\", (width, height), (255, 255,255))\n    self._pilImage.paste(oldImage, (0, 0))         \n    self._pilDraw = ImageDraw.Draw(self._pilImage)\n    \n  ## Returns the height of the canvas.\n  #\n  def height(self):\n    return self._pilImage.size[1]\n  \n  ## Returns the width of the canvas.\n  #\n  def width(self):\n    return self._pilImage.size[0]\n     \n  ## Clears the canvas by removing all items previously drawn on it. \n  #\n  def clear(self):\n    width = self.width()\n    height = self.height()\n    self._pilImage = Image.new(\"RGB\", (width, height), (255, 255,255))\n    self._pilDraw = ImageDraw.Draw(self._pilImage)\n   \n  ## Sets the current background color of the canvas. (not used)\n  #   \n  def setBackground(self, red, green = None, blue = None) :\n    if type(red) == int :\n      color = \"#%02X%02X%02X\" % (red, green, blue) \n    elif type(red) != str :\n      raise GraphicsParamError(\"Invalid color.\")\n    else :\n      color = red\n\n  ## Sets the fill color used when drawing new polygon shapes. \n  #    \n  def setFill(self, red = None, green = None, blue = None) :\n    if red is None :\n      color = None\n    elif type(red) == int :\n      color = (red, green, blue)       \n    elif type(red) != str :\n      raise GraphicsParamError(\"Invalid color.\")\n    else :\n      string = red.replace(\" \", \"\")\n      color = ImageColor.getrgb(string)\n    self._polyOpts[\"fill\"] = color\n        \n  ## Sets the outline color used when drawing new polygon shapes and the\n  #\n  def setOutline(self, red = None, green = None, blue = None) :\n    if red is None :\n      color = None\n    elif type(red) == int :\n      color = (red, green, blue)  \n    elif type(red) != str :\n      raise GraphicsParamError(\"Invalid color.\")\n    else :\n      string = red.replace(\" \", \"\")\n      color = ImageColor.getrgb(string)\n    self._polyOpts[\"outline\"] = color\n    self._textOpts[\"fill\"] = color\n     \n  ## Sets both the fill and outline colors used when drawing shapes and text\n  #  on the canvas. \n  #\n  def setColor(self, red, green = None, blue = None) :\n    if type(red) == int :\n       color = (red, green, blue)\n    elif type(red) != str :\n       raise GraphicsParamError(\"Invalid color.\")\n    else :\n       string = red.replace(\" \", \"\")\n       color = ImageColor.getrgb(string)\n    self._polyOpts[\"outline\"] = color\n    self._polyOpts[\"fill\"] = color\n    self._textOpts[\"fill\"] = color     \n    \n  ## Sets the width of lines drawn on the canvas. \n  #\n  def setLineWidth(self, size):\n    if type(size) != int or size \u003C= 0 :\n      raise GraphicsParamError(\"Invalid line width.\")\n    self._polyOpts[\"width\"] = size\n    if self._polyOpts[\"dash\"] :\n      self._polyOpts[\"dash\"] = (4 * size, 4 * size)\n\n  ## Sets the style used to drawn lines on the canvas. (not used) \n  #\n  def setLineStyle(self, style):\n    if style == \"dashed\" :\n      width = self._polyOpts[\"width\"]\n      self._polyOpts[\"dash\"] = (4 * width, 4 * width)\n    else :\n      self._polyOpts[\"dash\"] = None\n\n\n  ## Sets the style used when drawing an arc on the canvas. \n  #\n  def setArcStyle(self, style) :\n    if style not in (\"pieslice\", \"chord\", \"arc\") :\n      raise GraphicsParamError(\"Invalid arc style.\")\n    self._arcStyle = \"pieslice\"\n  \n  ## Sets the font used to draw text on the canvas. \n  #  \n  def setTextFont(self, family = None, style = None, size = None ):\n    origFamily, origSize, origStyle = self._textOpts[\"font\"]\n    if family is None :\n      family = origFamily    \n    elif (family is not None and \n       family not in ('helvetica', 'arial', 'courier', 'times', 'times roman')) :\n      raise GraphicsParamError(\"Invalid font family.\")\n      \n    if style is None :\n      style = origStyle    \n    elif (style is not None and \n       style not in ('bold', 'normal', 'italic', 'bold italic')) :\n      raise GraphicsParamError( \"Invalid font style.\" )\n\n    if size is None :\n       size = origSize    \n    elif size is not None and (type(size) != int or size \u003C= 0) :\n      raise GraphicsParamError( \"Invalid font size.\" )\n       \n    self._textOpts[\"font\"] = (family, size, style)     \n\n  ## Sets the position that text is drawn in relation to a bounding box. \n  #\n  def setTextAnchor(self, position):\n    if position not in ('n', 's', 'e', 'w', 'nw', 'ne', 'sw', 'se', 'center') :\n      raise GraphicsParamError( \"Invalid anchor position.\" )       \n    self._textOpts[\"anchor\"] = position\n          \n  ## Sets the justification used to draw new multiline text on the canvas.\n  #\n  def setTextJustify(self, style):\n    if style in (\"left\", \"center\", \"right\") :\n      self._textOpts[\"justify\"] = style\n    else :\n      raise GraphicsParamError(\"Invalid justification value.\")\n    \n  ## Draws or plots a single point (pixel) on the canvas.\n  #\n  def drawPoint(self, x, y) :\n    self._pilDraw.point((round(x), round(y), round(x+1), round(y)), \n                        fill=self._polyOpts[\"outline\"])\n    return 0    \n\n  ## Draws a line segment on the canvas. \n  #\n  def drawLine(self, x1, y1, x2, y2):\n    self._pilDraw.line((round(x1), round(y1), round(x2), round(y2)), \n      fill=self._polyOpts[\"outline\"],\n      width=self._polyOpts[\"width\"])\n    return 0\n  \n  ## Draws an arrow or vector on the canvas. (Draws a line) \n  #\n  def drawArrow(self, x1, y1, x2, y2) :\n    return self.drawLine(x1, y1, x2, y2)\n    \n  ## Draws a rectangle on the canvas. \n  #\n  def drawRect(self, x, y, width, height) :\n    self._pilDraw.rectangle((round(x), round(y), \n                             round(x + width), round(y + height)), \n              outline=self._polyOpts[\"outline\"], fill=self._polyOpts[\"fill\"])\n    return 0\n  \n  def drawRectangle(self, x, y, width, height) :\n    return self.drawRect(x, y, width, height)\n                       \n  ## Draws a polygon on the canvas. \n  #\n  def drawPoly(self, *coords):\n    minCoords = 6\n    \n     # Unwrap the cooridinates which allows the method to accept individual \n     # vertices or a list of vertices.\n    if len(coords) == 1 and (type(coords[0]) == list or type(coords[0]) == tuple) :\n       expCoords = tuple(*coords)\n    else :\n       expCoords = coords\n       \n    if type(expCoords[0]) == list or type(expCoords[0]) == tuple :\n      minCoords = 3\n       \n    if len(expCoords) \u003C minCoords :\n      raise GraphicsParamError(\"At least 3 vertices must be provided.\")\n      \n    self._pilDraw.polygon(expCoords, \n              outline=self._polyOpts[\"outline\"], fill=self._polyOpts[\"fill\"])\n    return 0\n  \n  ## The same as drawPoly().\n  #\n  def drawPolygon(self, *coords) :\n    return self.drawPoly(*coords)\n      \n  ## Draws an oval on the canvas. \n  #\n  def drawOval(self, x, y, width, height):\n    self._pilDraw.ellipse((round(x), round(y), \n                           round(x + width), round(y + height)),\n              outline=self._polyOpts[\"outline\"], fill=self._polyOpts[\"fill\"])\n    return 0    \n            \n  ## Draws an arc or part of a circle on the canvas.\n  #\n  def drawArc(self, x, y, diameter, startAngle, extent) :\n    x = round(x)\n    y = round(y)\n    diameter = round(diameter)\n    startAngle = round(startAngle)\n    extent = round(extent)\n\n     # Tk draws arcs counter-clockwise, but PIL draws them clockwise.\n    temp = startAngle\n    endAngle = 360 - temp\n    startAngle = 360 - temp - extent\n    if self._arcStyle == \"pieslice\" :\n      self._pilDraw.pieslice((x, y, x + diameter, y + diameter), \n                          startAngle, endAngle,\n                          outline=self._polyOpts[\"outline\"],\n                          fill=self._polyOpts[\"fill\"])\n      \n    elif self._arcStyle == \"chord\" :\n      self._pilDraw.chord((x, y, x + diameter, y + diameter), \n                          startAngle, endAngle,\n                          outline=self._polyOpts[\"outline\"],\n                          fill=self._polyOpts[\"fill\"])\n      \n    elif self._arcStyle == \"arc\" :\n      self._pilDraw.arc((x, y, x + diameter, y + diameter), \n                          startAngle, endAngle,        \n                          fill=self._polyOpts[\"outline\"])\n    \n    return 0\n  \n  ## Draws text on the canvas. \n  #  \n  def drawText(self, x, y, text):\n    self._pilDraw.text((round(x), round(y)), text,\n                fill=self._textOpts[\"fill\"],\n                anchor=self._textOpts[\"anchor\"],\n                font=self._font)\n    return 0\n         \n  ## Draws an image onto the canvas.\n  #\n  def drawImage(self, x, y = None, image = None) :\n    if type(x) == GraphicsImage :\n      image = x\n      width = image.width()\n      height = image.height()\n      x = 0\n      y = 0\n      self._pilImage = Image.new(\"RGB\", (width, height), (255, 255,255))\n      self._pilDraw = ImageDraw.Draw(self._pilImage)\n      \n    self._pilImage.paste(image._pilImage, (round(x), round(y)))\n    return 0\n  \n  def shiftItem(self, itemId, dx, dy) :\n    pass\n  \n  def scaleItem(self, itemId, xScale, yScale, xOffset = None, yOffset = None) :\n    pass\n  \n  def removeItem(self, itemId) :\n    pass\n  \n  def showItem(self, itemId) :\n    pass\n  \n  def hideItem(self, itemId) :\n    pass\n  \n  def raiseItem(self, itemId, aboveId = None) :    \n    pass\n\n  def lowerItem(self, itemId, belowId = None) :\n    pass\n  \n  def __contains__(self, itemId):\n    return True\n  \n  def itemType(self, itemId) :\n    return \"\"\n    \n  def items(self) :\n    return []    \n    \n  def itemAbove(self, itemId) :\n    return 0\n\n  def itemBelow(self, itemId) :\n    return 0\n    \n    \n## This class defines a basic top level window that can display a\n#  digital GraphicsImage.\n#\nclass ImageWindow(GraphicsWindow) :\n  \n  ## Creates a new window for displaying images. This provides a quick\n  #  way to display images without having to access and draw on the \n  #  canvas of a graphics window.\n  #         \n  def __init__(self) :\n    super().__init__(None, None)\n    self._imgId = None\n    \n  ## Displays an image in the window. The window is resized to fit tightly\n  #  around the image.\n  #  @param image  The GraphicsImage object containing the image to \n  #                be displayed.\n  #\n  def display(self, image = None) :\n    if image is None : return\n    canvas = self._canvas\n    width = image.width()\n    height = image.height()\n    canvas._pilImage = Image.new(\"RGB\", (width, height), (255, 255, 255)) \n    canvas._pilImage.paste(image, (0, 0))\n    \n## This class defines an RGB digital image that is contained within an\n#  ImageWindow.\n#\nclass GraphicsImage :\n  \n  ## Creates a new graphics image. \n  #\n  def __init__(self, width = None, height = None) :\n     # Create the photo image.\n    if height is None and type(width) == str :\n      filename = width\n      self._pilImage = Image.open(filename)\n      if self._pilImage.mode != \"RGB\" :\n        self._pilImage = self._pilImage.convert(\"RGB\")\n    else :\n      self._pilImage = Image.new(\"RGB\", (width, height), (255, 255,255))\n  \n  ## Gets the width of the image in pixels.\n  #  @return The width of the image.\n  #\n  def width(self) :\n    return self._pilImage.size[0]\n\n  ## Gets the height of the image in pixels.\n  #  @return The width of the image.\n  #\n  def height(self) :\n    return self._pilImage.size[1]\n\n  ## Sets a pixel to a given RGB color.\n  #\n  def setPixel(self, row, col, *rgbColor) :\n    if (row \u003C 0 or row \u003E= self.height() or\n        col \u003C 0 or col \u003E= self.width()) : \n      return\n    if len(rgbColor) == 1 :\n      if type(rgbColor[0]) == str :\n        if rgbColor[0][0] == \"#\" :\n          color = ImageColor.getrgb(rgbColor)\n        else :\n          color = (0, 0, 0)\n      else :\n        color = tuple(*rgbColor)\n    elif len(rgbColor) == 3 :\n      color = rgbColor      \n    col = round(col)\n    row = round(row)\n    color = (int(color[0]), int(color[1]), int(color[2]))    \n    self._pilImage.putpixel((col, row), color)\n  \n  ## Returns a 3-tuple containing the RGB color of a given pixel.\n  #\n  def getPixel(self, row, col) :\n    row = round(row)\n    col = round(col)\n    result = self._pilImage.getpixel((col, row))\n    if type(result) == int :\n      return (result, result, result)\n    else :\n      return result\n\n  ## Returns the red component of the RGB color of a given pixel.\n  #\n  def getRed(self, row, col) :\n    pixel = self.getPixel(row, col)\n    return pixel[0]\n    \n  ## Returns the green component of the RGB color of a given pixel.\n  #\n  def getGreen(self, row, col) :\n    pixel = self.getPixel(row, col)\n    return pixel[1]\n    \n  ## Returns the blue component of the RGB color of a given pixel.\n  #\n  def getBlue(self, row, col) :\n    pixel = self.getPixel(row, col)\n    return pixel[2]\n    \n  ## Clears the image and removes all of the pixels but the size of the \n  #  image remains the same.\n  #\n  def clear(self) :\n    width = self.width()\n    height = self.height()    \n    self._pilImage = Image.new(\"RGB\", (width, height), (255, 255,255))\n    \n  ## Creates a duplicate copy of the image.\n  #\n  def copy(self) :\n    image = GraphicsImage(10, 10)\n    image._pilImage = self._pilImage.copy()\n    return image\n  \n  ## Saves the digital image to a file in either the gif or ppm format.\n  #\n  def save(self, filename, format=\"gif\") :\n    if format not in (\"gif\", \"ppm\") :\n      raise GraphicsParamError( \"Invalid image format.\")\n    self._pilImage.save(filename, format=format)\n\n\n# --- Defines special graphics exceptions that are raised when an error\n# --- occurs in a GraphicsWindow method.\n\nclass GraphicsError(Exception) :\n  def __init__( self, message ):\n    super(GraphicsError, self).__init__( message )\n\nclass GraphicsObjError(GraphicsError) :\n  def __init__( self ):\n    super(GraphicsError, self).__init__( \"Invalid object id.\" )\n\nclass GraphicsWinError(GraphicsError) :\n  def __init__( self ):\n    super(GraphicsWinError, self).__init__(\n              \"Operation can not be performed on a closed window.\" )\n\nclass GraphicsParamError(GraphicsError) :\n  def __init__( self, message ):\n    super(GraphicsParamError, self).__init__( message )\n    \n",
    'triangles-img.gif': {
      data: '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'
    }
  }
})
